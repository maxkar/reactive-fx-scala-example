package ru.maxkar.reactive.value.event

import ru.maxkar.reactive.wave.Participant
import ru.maxkar.reactive.wave.Participable

/**
 * Event source trait. Each event source have a
 * specific type of "events". These events can be accessed
 * at any moment, but you can get meaningful values only
 * during the wave propagation, after this event was
 * resolved and wave was is not complete yet.
 * @param T event type.
 */
trait Event[T] {
  /**
   * Returns value of this node. This can be set to
   * some "neutral" value when this node does not
   * participate in the flow.
   * @param event generated by this node during a current wave.
   */
  def value() : T



  /**
   * Adds a "correlated" node. That node will be added to the
   * flow each time this source node parcitipates in that flow.
   */
  def addCorrelatedNode(node : Participant) : Unit



  /**
   * Removes previously added correlated node. If node was added
   * multiple times, decreases number of correlations by one.
   */
  def removeCorrelatedNode(node : Participant) : Unit



  /**
   * Defers evaluation of target node until this event node
   * is completely resolved (i.e. all events are generated)
   * during current wave.
   * @param target target to defer. This node should be engaged in the wave.
   */
  def defer(target : Participant) : Unit
}



/**
 * Event access point.
 */
object Event {
  /** Empty event with fixed false value. */
  val constFalseEvent : Event[Boolean] = new Event[Boolean] {
    override def value() = false
    override def addCorrelatedNode(node : Participant) = ()
    override def removeCorrelatedNode(node : Participant) = ()
    override def defer(node : Participant) = ()
  }



  /** Creates a new "trigger" event.
   * @param ctx current initialization context.
   */
  def trigger(implicit ctx : Participable) : Trigger =
    new Trigger(ctx)



  /**
   * Creates a basic event from node and producer function.
   * All correlations and deferrances will be associated with
   * the target paticipant. Value of the event will be retreived
   * using a given producer.
   * @param T event type.
   * @param participant participant associated with the event node.
   * @param event event producing function.
   */
  def fromParticipant[T](participant : Participant, event : â‡’ T) : Event[T] =
    new Event[T] {
      override def value() : T = event
      override def addCorrelatedNode(node : Participant) : Unit =
        participant.addCorrelatedNode(node)
      override def removeCorrelatedNode(node : Participant) : Unit =
        participant.removeCorrelatedNode(node)
      override def defer(node : Participant) : Unit =
        node.defer(participant)
    }
}

